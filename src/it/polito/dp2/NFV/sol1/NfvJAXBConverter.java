package it.polito.dp2.NFV.sol1;

import java.util.GregorianCalendar;
import java.util.List;

import javax.xml.bind.JAXBElement;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;

import it.polito.dp2.NFV.*;

// Import java content classes generated by binding compiler
import it.polito.dp2.NFV.sol1.jaxb.*;

public class NfvJAXBConverter {
	/**
	 * Reader from which data has to be retrieved
	 */
	private NfvReader monitor;

	/**
	 * Default constructor creating a converter with a given monitor
	 * @param monitor NFV reader object from which data can be read
	 */
	public NfvJAXBConverter(NfvReader monitor) {
		this.monitor = monitor;
	}

	/**
	 * Converts the NFV object obtainable by NfvReader
	 * into a JAXB equivalent class
	 * @return the NFV JAXB-compatible object
	 */
	public JAXBElement<NFVType> getNfvInfo() {
		// Retrieving the catalog
		CatalogType catalog = getCatalog();
		
		// Retrieving network
		NetworkType network = getNetwork();
		
		// Retrieving NF-FGs
		NffgsType nffgs = getNffgs();
		
		NFVType nfvInfo = new NFVType();
		nfvInfo.setCatalog(catalog);
		nfvInfo.setNetwork(network);
		nfvInfo.setNffgs(nffgs);
		
		return new ObjectFactory().createNfvInfo(nfvInfo);
	}
	
	/**
	 * Retrieves the NFV's catalog
	 * @return the catalog containing VNFs
	 */
	private CatalogType getCatalog() {
		CatalogType catalog = new CatalogType();
		List<VNFType> catalogList = catalog.getVNF();
		for(VNFTypeReader vnf: monitor.getVNFCatalog()) {
			VNFType tempVnf = new VNFType();
			tempVnf.setId(vnf.getName());
			tempVnf.setFunctionalType(
				FunctionalTypeType.fromValue(
						vnf.getFunctionalType().value()
				)
			);			
			tempVnf.setRequiredMemory(vnf.getRequiredMemory());
			tempVnf.setRequiredStorage(vnf.getRequiredStorage());
			catalogList.add(tempVnf);
		}
		
		return catalog;
	}
	
	/**
	 * Retrieves the physical network 
	 * @return the infrastructure network (IN) composed by hosts and channels
	 */
	private NetworkType getNetwork() {
		NetworkType network = new NetworkType();
		HostsType hosts = getHosts();
		ChannelsType channels = getChannels();
		network.setHosts(hosts);
		network.setChannels(channels);
		
		return network;
	}
	
	/**
	 * Retrieves the infrastructure network's (IN) hosts
	 * @return hosts belonging to the network
	 */
	private HostsType getHosts() {
		HostsType hosts = new HostsType();
		List<HostType> hostsList = hosts.getHost();
		for(HostReader host: monitor.getHosts()) {
			HostType tempHost = new HostType();
			tempHost.setAvailableMemory(host.getAvailableMemory());
			tempHost.setAvailableStorage(host.getAvailableStorage());
			tempHost.setId(host.getName());
			tempHost.setMaxVNFs(host.getMaxVNFs());
			
			// Adding node references
			if(!host.getNodes().isEmpty()) {
				List<NodeRefType> nodeRefList = tempHost.getNode();
				for(NodeReader nodeRef: host.getNodes()) {
					NodeRefType tempNodeRef = new NodeRefType();
					tempNodeRef.setId(nodeRef.getName());
					nodeRefList.add(tempNodeRef);
				}
			}
			
			hostsList.add(tempHost);
		}
		
		return hosts;
	}
	
	/**
	 * Retrieves the infrastructure network's (IN) channels
	 * @return channels present in the network
	 */
	private ChannelsType getChannels() {
		ChannelsType channels = new ChannelsType();
		List<ChannelType> channelsList = channels.getChannel();
		
		for(HostReader host1: monitor.getHosts()) {
			for(HostReader host2: monitor.getHosts()) {
				ConnectionPerformanceReader connection = 
						monitor.getConnectionPerformance(host1, host2);
				
				ChannelType channel = new ChannelType();
				channel.setHost1(host1.getName());
				channel.setHost2(host2.getName());
				channel.setAverageLatency(connection == null ? null : connection.getLatency());
				channel.setAverageThroughput(connection == null ? null : connection.getThroughput());
				
				channelsList.add(channel);
			}
		}
		
		return channels;
	}
	
	/**
	 * Retrieves the NF-FGs of the NFV system
	 * @return hosts belonging to the network
	 */
	private NffgsType getNffgs() {
		NffgsType nffgs = new NffgsType();
		List<NffgType> nffgList = nffgs.getNffg();
		for(NffgReader nffg: monitor.getNffgs(null)) {
			NffgType tempNffg = new NffgType();
			tempNffg.setId(nffg.getName());
			
			// Converting the deploy time
			GregorianCalendar gdp = new GregorianCalendar();
			gdp.setTime(nffg.getDeployTime().getTime());
			try {
				tempNffg.setDeployTime(DatatypeFactory.newInstance().newXMLGregorianCalendar(gdp));
			} catch(DatatypeConfigurationException e) {
				System.err.println("error");
				e.printStackTrace();
			}
			
			// Nffg's nodes
			getNodes(nffg, tempNffg);
			
			nffgList.add(tempNffg);
		}
		
		return nffgs;
	}
	
	/**
	 * Retrieves all nodes belonging to a given NF-FG
	 * @param nffg		the NF-FG of which nodes have to be retrieved		
	 * @param tempNffg	the NF-FG JAXB compatible object to be filled
	 */
	private void getNodes(NffgReader nffg, NffgType tempNffg) {
		NodesType nodes = new NodesType();
		List<NodeType> nodesList = nodes.getNode();
		for(NodeReader node: nffg.getNodes()) {
			NodeType tempNode = new NodeType();
			tempNode.setId(node.getName());
			tempNode.setFunctionalType(
				node.getFuncType().getName()
			);
			tempNode.setHost(node.getHost() == null ? null : node.getHost().getName());
			
			// Node's links
			getLinks(node, tempNode);
			
			nodesList.add(tempNode);
		}
		
		tempNffg.setNodes(nodes);
	}

	/**
	 * Retrieves all links involving a specific node
	 * @param nffg		the node of which links have to be retrieved		
	 * @param tempNffg	the node JAXB compatible object to be filled
	 */
	private void getLinks(NodeReader node, NodeType tempNode) {
		if(!node.getLinks().isEmpty()) {
			List<LinkType> linksList = tempNode.getLink();
			for(LinkReader link: node.getLinks()) {
				LinkType tempLink = new LinkType();
				tempLink.setId(link.getName());
				tempLink.setSourceNode(link.getSourceNode().getName());
				tempLink.setDestinationNode(link.getDestinationNode().getName());
				tempLink.setMinimumThroughput(link.getThroughput() == 0 ? null : link.getThroughput());
				tempLink.setMaximumLatency(link.getLatency() == 0 ? null : link.getLatency());
				linksList.add(tempLink);
			}
		}
	}
}